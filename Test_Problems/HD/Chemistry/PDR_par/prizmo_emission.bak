module prizmo_emission

  !!BEGIN_EMISSION_COMMONS

  !!END_EMISSION_COMMONS

  real*8,parameter::nlimit_frac = 1d-20
  real*8::xdata(nsteps)
  real*8::emission_array_energy(ntransitions)
  real*8::emission_array_flux(ntransitions)
  character(len=50)::emission_array_names(ntransitions)

contains

  ! **************************
  subroutine load_emission_data()
    implicit none
    !!BEGIN_EMISSION_LOAD

    !!END_EMISSION_LOAD

    call load_emission_names()

  end subroutine load_emission_data

  ! **************************
  ! load emission names as string
  subroutine load_emission_names()
    implicit none
    integer::i, unit

    open(newunit=unit, file="runtime_data/emission_names_list.dat", status="old")
    do i=1,ntransitions
      read(unit, '(a50)') emission_array_names(i)
    end do
    close(unit)

  end subroutine load_emission_names

  ! **************************
  ! load collisional rates from file, k(i, j, Tgas), cm-3/s
  subroutine load_data_kcoll(fname, nlevels, kdata)
    implicit none
    character(len=*),intent(in)::fname
    integer,intent(in)::nlevels
    integer::unit, j, ilev, jlev, ios
    real*8::ydata(nsteps)
    real*8,intent(out)::kdata(nlevels, nlevels, nsteps)

    ! i_level, j_level, Tgas_index
    ! large negative because fit is in log space
    kdata(:, :, :) = -1d99

    ! open file to read
    open(newunit=unit, file=trim(fname), status="old", iostat=ios)
    ! check if file exists
    if(ios /= 0) then
      print *, "ERROR: problems with "//trim(fname)
      stop
    end if

    ! loop to load, files are i_level, j_level blocks
    ! with nsteps temperature steps each
    do
      !read levels number
      read(unit, *, iostat=ios) ilev, jlev
      ! read until it can
      if (ios /= 0) then
        exit
      end if
      ! loop on temperature steps
      do j=1,nsteps
        read(unit, *) xdata(j), ydata(j)
      end do
      ! store log of data
      kdata(jlev, ilev, :) = log10(ydata(:) + 1d-40)
    end do
    close(unit)

    ! temperature grid is the same for all the collisional rates (commons)
    xdata(:) = log10(xdata)

  end subroutine load_data_kcoll

  ! ******************************
  ! load Aij coefficients, 1/s
  subroutine load_data_Aij(fname, nlevels, Aij)
    implicit none
    character(len=*),intent(in)::fname
    integer,intent(in)::nlevels
    integer::unit, ilev, jlev, ios
    real*8::aval
    real*8,intent(out)::Aij(nlevels, nlevels)

    ! i_level, j_level
    Aij(:, :) = 0d0

    ! read from file
    open(newunit=unit, file=fname, status="old")
    ! loop on transitions
    do
      read(unit, *, iostat=ios) ilev, jlev, aval
      ! read until it can
      if (ios /= 0) then
        exit
      end if
      ! transitions are stored into Aij=Aul matrix
      Aij(jlev, ilev) = aval
    end do
    close(unit)

  end subroutine load_data_Aij

  ! *********************
  ! get atomic cooling from emission, erg/s/cm3
  function get_atomic_cooling(n, Tgas_in) result(cool)
    use prizmo_commons
    use prizmo_utils
    implicit none
    real*8,intent(in)::n(nmols), Tgas_in
    real*8::n_pH2, n_oH2, logTgas, cool, Tgas, nlimit

    !!BEGIN_ATOMIC_COOLING_POPULATION_DECLARE

    !!END_ATOMIC_COOLING_POPULATION_DECLARE

    ! density limit to compute cooling, cm-3
    nlimit = nlimit_frac * get_ntot(n(:))

    ! compute ortho/para ratio
    n_pH2 = n(idx_H2) / (opratio_H2 + 1d0)
    n_oH2 = n(idx_H2) - n_pH2

    ! check Tgas range
    Tgas = max(min(Tgas_in, Tgas_max), Tgas_min)

    ! log of Tgas for rate interpolation
    logTgas = log10(Tgas)

    !!BEGIN_ATOMIC_COOLING_POPULATION

    !!END_ATOMIC_COOLING_POPULATION

    cool = 0d0

    !!BEGIN_ATOMIC_COOLING_TOTAL

    !!END_ATOMIC_COOLING_TOTAL

  end function get_atomic_cooling

  ! *********************
  ! add emission from given chemical species to the emission array
  subroutine add_emission(emission, n, Tgas_in)
    use prizmo_commons
    use prizmo_utils
    implicit none
    real*8,intent(in)::n(nmols), Tgas_in
    real*8,intent(inout)::emission(nphoto)
    real*8::Tgas, logTgas, n_pH2, n_oH2, emission_lost, nlimit
    !!BEGIN_EMISSION_POPULATION_DECLARE

    !!END_EMISSION_POPULATION_DECLARE

    ! density limit to compute cooling, cm-3
    nlimit = nlimit_frac * get_ntot(n(:))

    ! compute ortho/para ratio
    n_pH2 = n(idx_H2) / (opratio_H2 + 1d0)
    n_oH2 = n(idx_H2) - n_pH2

    ! check Tgas range
    Tgas = max(min(Tgas_in, Tgas_max), Tgas_min)

    ! log of Tgas for rate interpolation
    logTgas = log10(Tgas)

    !!BEGIN_EMISSION_POPULATION

    !!END_EMISSION_POPULATION


    !!BEGIN_EMISSION_TOTAL

    !!END_EMISSION_TOTAL

  end subroutine add_emission

  ! **************
  ! add collisional rates to the Cij matrix for a given collider
  ! using linear interpolation in temperature
  ! kcoll, matrix contating the fit data for each transition
  ! logTgas, log10(temperature), log10(K)
  ! nlevels, number of levels
  ! ncollider, abundance of the collider, cm-3
  subroutine add_Cij(Cij, kcoll, logTgas, nlevels, ncollider)
    implicit none
    integer,intent(in)::nlevels
    real*8,intent(in)::logTgas, kcoll(nlevels, nlevels, nsteps), ncollider
    real*8::k(nlevels, nlevels), Cij(nlevels, nlevels), pre
    integer::idx

    ! find index
    idx = floor((logTgas - kcoll_xmin) * kcoll_fact) + 1

    if(idx < 1) then
      !print *, idx, logTgas, kcoll_xmin
      idx = max(idx, 1)
    end if

    ! precompute fit factor
    pre = (logTgas - xdata(idx)) * kcoll_invdx
    ! do fit
    k(:, :) = 1d1**(pre * (kcoll(:, :, idx+1) - kcoll(:, :, idx)) + kcoll(:, :, idx))

    ! add rate to the matrix
    Cij(:, :) = Cij(:, :) + k(:, :) * ncollider

  end subroutine add_Cij

  ! *********************
  ! compute level population with the given atomic data
  ! Aij, matrix of dexctiation coefficients, 1/s
  ! Cij, matrix of (de)exctiation collisiona rate coefficients, cm-3/s
  ! nlevels, number of energy levels
  ! ncool, coolant number density, cm-3
  ! returns: levels array of population number density, cm-3
  ! see https://www.aanda.org/articles/aa/pdf/2009/25/aa11821-09.pdf
  function population(Aij, Cij, nlevels, ncool) result(n)
    use prizmo_commons
    use prizmo_linear_solver
    implicit none
    integer,intent(in)::nlevels
    real*8,intent(in)::Aij(nlevels, nlevels), ncool
    real*8::Cij(nlevels, nlevels), Rij(nlevels, nlevels), pre, n(nlevels), logT
    integer::idx, i, j, ierr, ipiv(nlevels)

    ! Rij is a matrix where indexes are levels (up, low)
    Rij(:, :) = Aij(:, :) + Cij(:, :)

    ! loop on the diagonal to construct the negative terms of the matrix.
    ! summing Rij(i, i) is for consistency, but it should be already zero
    ! since Aii and Cii are both not transitions (hence they are both zero)
    do i=1,nlevels
      Rij(i, i) = -sum(Rij(:, i)) + Rij(i, i)
    end do

    ! first row is set to one for mass conservation
    Rij(1, :) = 1d0
    ! RHS of the system Rij * x = n
    n(1) = ncool
    n(2:nlevels) = 0d0

    ! use analytical linear solver for system of size 2 and 3
    ! dgesv otherwise
    n(:) = linear_solver(Rij(: ,:), n(:))

    ! avoid negative levels
    do i=1,nlevels
      n(i) = max(n(i), 0d0)
    end do

    ! normalize to ensure mass conservation
    n(:) = n(:) / (sum(n) + 1d-40) * ncool

  end function population

  ! ***********************
  ! line optical thickness (escape probability)
  ! Tielens+2005, pag.50, eqns. 2.43-2.45
  ! input arguments are cgs
  ! Aul, Einstein coefficient
  ! Eul, energy difference
  ! dvdz_in, velocity gradient
  ! n_up, n_low, population of the levels
  ! g_up, g_low, statistical weight
  function beta_escape(Aul, Eul, dvdz_in, n_up, n_low, g_up, g_low) result(beta)
    use prizmo_commons
    implicit none
    real*8,intent(in)::Aul, Eul, dvdz_in, n_up, n_low, g_up, g_low
    real*8,parameter::pre=(clight * hplanck)**3 / 8e0 / pi
    real*8::tau_ul, beta

    if(beta_escape_mode == -1) then
      beta = 1d0
      return
    end if

    tau_ul = pre * Aul / Eul**3 * n_up / dvdz_in * (n_low * g_up / (n_up + 1d-40) / g_low - 1d0)
    ! this avoids numerical instability
    tau_ul = max(tau_ul, 1d-10)

    if(tau_ul > 7d0) then
       beta = 1d0 / (4d0 * tau_ul * sqrt(log(tau_ul / sqrt(pi))))
    else
       beta = (1d0 - exp(-2.34 * tau_ul)) / 4.68d0 / tau_ul
    end if

    ! check limits
    if(beta < 0d0 .or. beta > 1d0) then
       print *, "ERROR: problem with beta escape!"
       print *, " beta < 0 or beta > 1:", beta
       stop
    end if

  end function beta_escape


end module prizmo_emission
